<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="Word2Vec-语言模型的前世今生, Young&#39;s Blog">
    <meta name="description" content="引言
在机器学习领域，语言识别和图像识别都比较容易做到。语音识别的输入数据可以是音频频谱序列向量所构成的matrix，图像识别的输入数据是像素点向量构成的矩阵。但是文本是一种抽象的东西，显然不能直接把文本数据喂给机器当做输入，因此这里就需要">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Word2Vec-语言模型的前世今生 | Young&#39;s Blog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Young's Blog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Young's Blog</div>
        <div class="logo-desc">
            
            每个人都是平凡的，同时也是与众不同的。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Word2Vec-语言模型的前世今生
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/自然语言处理/" target="_blank">
                                <span class="chip bg-color">自然语言处理</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/NLP/" class="post-category" target="_blank">
                                NLP
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2018-03-27
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><img src="/picture/feeding.jpg" alt="picture"></p>
<p>在机器学习领域，语言识别和图像识别都比较容易做到。语音识别的输入数据可以是音频频谱序列向量所构成的matrix，图像识别的输入数据是像素点向量构成的矩阵。但是文本是一种抽象的东西，显然不能直接把文本数据喂给机器当做输入，因此这里就需要对文本数据进行处理。</p>
<p>现在，有这么一个有趣的例子，我接下来要讲的模型就可以做到。</p>
<ul>
<li>首先给出一个例子，Paris - France + America = ?</li>
</ul>
<p>从我们人的角度来看,Paris是法国的首都，那么首都减去国家再加上一个国家，很可能表示的就是另一个国家的首都。因此这里的结果就是华盛顿Washington.机器想做到这一点，并不容易。</p>
<ul>
<li><p>众所周知，只有标量或者向量可以应用加减法，抽象的自然语言该如何做到呢？</p>
</li>
<li><p>一个很自然的想法就是，自然语言能否表示成数学的形式，这样就可以更加方便地研究其规律了。</p>
</li>
<li><p>答案是肯定的。</p>
</li>
</ul>
<p>现在我们可以进行思考，如何将文本中的词语用数学的形式表达出来,也就是说，文本中藏着哪些数学形式需要我们去挖掘。</p>
<ol>
<li><p>文本中各个词语出现的频数是有限的，这是一个可以提取的数学形式</p>
</li>
<li><p>从逻辑的角度出发，词语之间不可能是独立的，一个词语的出现肯定与另一个或者若干个词语有关系。这就涉及到词语共现的层面了。</p>
</li>
</ol>
<p>统计语言模型和大多数的词向量表示都是基于以上两点考虑的。</p>
<p>词向量的表现形式主要分为两种，一种是one-hot(one-hot representation)表示方式，将词表示成一个很长的向量，向量的长度就是词典的长度；另一种表示方法是分布式表示(distributed representation).同时，分布式表示方法又可以分为基于矩阵的表示方法、基于聚类的表示方法和基于神经网络的表示方法。</p>
<p>首先，最简单的就是one-hot表示方法，将词表示成一个很长的向量，向量的分量只有一个1，其他全为0，1所对应的位置就是该词在词汇表中的索引。</p>
<p>这样表示有两个缺点：</p>
<ol>
<li><p>容易受维度灾难(the curse of dimentionality)的困扰；</p>
</li>
<li><p>没有考虑到词之间的关系(similarity)。</p>
</li>
</ol>
<p>现在主要应用的都是分布式表示形式了。下面介绍一种简单的分布式表示形式——基于矩阵的表示形式。</p>
<p>如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Probability and Ratio</th>
<th>k = solid</th>
<th>k = gas</th>
<th>k = water</th>
<th>k = fashion</th>
</tr>
</thead>
<tbody>
<tr>
<td>$p(k\vert ice)$</td>
<td>$1.9\times 10^{-4}$</td>
<td>$6.6\times 10^{-5}$</td>
<td>$3.0\times 10^{-3}$</td>
<td>$1.7\times 10^{-5}$</td>
</tr>
<tr>
<td>$p(k\vert steam$)</td>
<td>$2.2\times 10^{-5}$</td>
<td>$7.8\times 10^{-4}$</td>
<td>$2.2\times 10^{-3}$</td>
<td>$1.8\times 10^{-5}$</td>
</tr>
<tr>
<td>$p(k\vert ice)/(p(k\vert steam)$</td>
<td>$8.9$</td>
<td>$8.5\times 10^{-2}$</td>
<td>$1.36$</td>
<td>$0.96$</td>
</tr>
</tbody>
</table>
</div>
<p>简单说一下上面的矩阵。</p>
<p>假设我们对一些热力学短语或者词语的概念感兴趣，我们选择i=ice，k=steam，我们想看看ice和steam的关系，可以通过他们与其他词语的共现频率来研究。这些其他词语我们称之为探测词。这里我们选择探测词k为solid，gas，water和fashion。显然，ice与solid的相关性较高，但是与steam相关性较低，因此我们期望看到的是$p_{ik}/p_{jk}$比值比较大。对于探测词gas，我们期望看到的是$p_{ik}/p_{jk}$比值比较小。而water和fashion与ice和steam的关系要么都十分密切，要么都不怎么密切，因此对于这两个探测词，$p_{ik}/p_{jk}$应该接近于1.</p>
<p>上表是基于一个很大的语料库统计得出的，符合我们的预期。相比于单独使用原始概率，概率比值可以更好的区分相关词语和不相关词语，比如solid和gas与water和fashion；也可以很容易区分两个相关词。</p>
<p>那么，在正式介绍自然语言处理，或者说wrod2vec之前，有必要介绍以下统计语言模型。它是现在所有语言模型的基础。</p>
<p>第二个需要讲的分布式表示方式是基于神经网络的表示方法。在此之前，有必要讲一下传统的统计语言模型，毕竟它对语言模型影响深远。</p>
<hr>
<h2 id="统计语言模型"><a href="#统计语言模型" class="headerlink" title="统计语言模型"></a>统计语言模型</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>给出以下三个句子：</p>
<pre><code>美联储主席本·伯南克昨天告诉媒体7000亿美元的救助资金将借给上百家银行、保险公司和汽车公司

美主席联储本·伯南克告诉昨天媒体7000亿美元的资金救助将借给百上家银行、保险公司和汽公车司

美主车席联储本·克告诉昨天公司媒体7000伯南亿美行元的金将借给百救助上家资银、保险公司和汽
</code></pre><p>对于第一个句子，语句通畅，意思也很不明白；对于第二个句子，虽然个别词语调换了位置，但也不影响阅读，我们仍然能够知道表达的是什么意思；对于第三个句子，我们就很难知道具体表示什么意思了。</p>
<p>如果问你为什么第三个句子不知道表达什么，你可能会说句子混乱，语义不清晰。在上个世纪70年代的时候，科学家们也是这样想的，并且试图让计算机去判断一个句子的语义是否清晰，然而，这样的方法是走不通的。</p>
<p><strong>贾里尼克</strong>想到了一种很好的统计模型来解决上述问题。判断一个句子是否合理，只需要看它在所有句子中出现的概率就行了。第一个句子出现的概率大概是$10^{-20}$,第二个句子出现的概率大概是$10^{-25}$，第三个句子出现的概率大概是$10^{-70}$，第一个句子出现的可能性最大，因此这个句子最为合理。</p>
<p>那么，如何计算一个句子出现的概率呢，我们可以把有史以来人类说过的话都统计一遍，这样就能很方便的计算概率了。然而，你我都知道这条路走不通。</p>
<p>假设想知道S在文本中出现的可能性，也就是数学上所说的S的概率，既然$S=w_1,w_2,…,w_n$,那么不妨把S展开表示，</p>
<script type="math/tex; mode=display">P(S)=P(w_1,w_2,...,w_n)</script><p>利用条件概率的公式，S这个序列出现的概率等于每一个词出现的条件概率的乘乘积，展开为：</p>
<script type="math/tex; mode=display">
P(w_1,w_2,...,w_n)=P(w_1)P(w_2\vert w_1)P(w_3\vert w_1,w_2)\cdots P(w_n\vert w_1,w_2,\cdots w_{n-1})</script><p>计算$P(w_1)$很容易，$P(w_2\vert w_1)$也还能算出来，$P(w_3\vert w_1,w_2)$已经非常难以计算了。</p>
<h3 id="2-偷懒的马尔科夫-Andrey-Markov"><a href="#2-偷懒的马尔科夫-Andrey-Markov" class="headerlink" title="2. 偷懒的马尔科夫(Andrey Markov)"></a>2. 偷懒的<strong>马尔科夫</strong>(Andrey Markov)</h3><p>假设上面的n不取很长，而只取2个，那么就可以大大减少计算量。即在此时，假设一个词$w_i$出现的概率只与它前面的$w_{i-1}$有关，这种假设称为1阶马尔科夫假设。</p>
<p>现在，S的概率就变得简单了：</p>
<script type="math/tex; mode=display">
P(w_1,w_2,...,w_n) \approx P(w_1)P(w_2\vert w_1)</script><p>那么，接下来的问题就变成了估计条件概率$P(w_i\vert w_{i-1})$,根据它的定义，</p>
<script type="math/tex; mode=display">
P(w_i\vert w_{i-1}) = \frac{P(w_i,w_{i-1})}{P(w_{i-1})}</script><p>,</p>
<p>当样本量很大的时候，基于大数定律，一个短语或者词语出现的概率可以用其频率来表示，即</p>
<script type="math/tex; mode=display">
P(w_i,w_{i-1})\approx \frac{count(w_i,w_{i-1})}{count(*)}</script><script type="math/tex; mode=display">
P(w_{i-1}) \approx \frac{count(w_{i-1})}{count(*)}</script><p>其中，$count(i)$表示词$i$出现的次数，$count$表示语料库的大小。</p>
<p>那么</p>
<script type="math/tex; mode=display">
P(w_i\vert w_{i-1}) = \frac{P(w_i,w_{i-1})}{P(w_{i-1})} \approx \frac{count(w_i,w_{i-1})}{count(w_{i-1})}</script><h3 id="3-高阶语言模型"><a href="#3-高阶语言模型" class="headerlink" title="3. 高阶语言模型"></a>3. 高阶语言模型</h3><p>在前面的模型中，每个词只与前面1个词有关，和更前面的词就没有关系了，这似乎简单的有点过头了。那么，假定每个词$w_i$都与前面的N-1个词有关，而与更前面的词无关，这样，当前词的概率只取决于前面N-1个词的联合概率，即</p>
<script type="math/tex; mode=display">
P(w_1\vert w_1,w_2,\cdots w_{i-1}) \approx P(w_1\vert w_{i-N+1},w_{i-N+2},\cdots w_{i-1})</script><p>,</p>
<p>上面这种假设被称为n-1阶马尔科夫假设，对应的模型称为N元模型。N=2就是二元模型，N=1其实就是上下文无关的模型，基本不怎么使用。</p>
<p>上面的模型看起来已经很完美了，但是考虑以下两个问题，对于二元模型：</p>
<p>如果此时$count(w_i,w_{i-1})=0$，是否可以说$P(w_i\vert w_{i-1})=0$ ?</p>
<p>如果此时$count(w_i,w_{i-1})=count(w_{i-1})$，是否可以说$P(w_i\vert w_{i-1})=1$ ?</p>
<p>显然，不能这么武断。</p>
<p>但是，实际上上述两种情况肯定是会出现的，尤其是语料足够大的时候，那么，我们怎么解决上述问题呢？</p>
<p>古德和图灵给出了一个很漂亮的重新估计概率的公式，这个公式后来被称为古德-图灵估计。</p>
<p>古德图灵的原理是：</p>
<pre><code>对于没有看见的事件，我们不能认为他发生的概率就是0，因此从概率的总量中，分配一个很小的比例给这些没有看见的事件。这样一来，看见的那些事件的概率就要小于1了，因此，需要将所有看见的事件的概率调小一点。至于小多少，要根据“越是不可信的统计折扣越多”的方法进行。
</code></pre><p>假定在语料库中出现$r$次的词有$N_r$个，特别的，未出现的词数量为$N_0$，语料库大小为$N$，那么，很显然，</p>
<script type="math/tex; mode=display">
N = \sum _{r=1}^ \infty rN_r</script><p>,</p>
<p>出现$r$次的词在整个语料库中的相对频度则是${rN_r}/{N}$，如果不做任何处理，这个相对频度作为这些词的概率。但是当$r$比较小的时候，统计上可能不可靠，因此需要使用一个更小的次数$d_r$来表示，古德-图灵按照如下公式计算$d_r$:</p>
<script type="math/tex; mode=display">
d_r=(r+1)\cdot N_{r+1}/N_r</script><p>,</p>
<p>显然</p>
<script type="math/tex; mode=display">
\sum_r d_r\cdot N_r = \sum_r (r+1)\cdot N_{r+1} = N</script><p>,</p>
<p>此时，</p>
<script type="math/tex; mode=display">
d_0 = (0+1)\cdot N_1/N_0 = \frac{N_1}{N_0} > 0</script><p>在实际处理的时候，一般对出现次数超过某个阈值的词，频率不下调。</p>
<p>基于这种思想，估计二元模型概率的公式如下：</p>
<script type="math/tex; mode=display">
P(w_i\vert w_{i-1})=
\begin{cases}
f(wi\vert w_{i-1}) & {if\quad count(w_{i-1},w_i)} \ge T \\
f_{gt}(w_i\vert w_{i-1})& if\quad 0 \le count(w_{i-1},w_i) < T \\
Q(w_{i-1})\cdot f(w_i) & otherwise
\end{cases}</script><p>,</p>
<p>其中, $f(\cdot)$ 表示相对频度，即频率。</p>
<script type="math/tex; mode=display">
Q(w_{i-1})=\frac{1-\sum_{w_i\quad seen}P(w_i \vert w_{i-1})}{\sum _{wi\quad unseen}f(w_i)}</script><p>上面这种方法称为卡茨退避法。</p>
<p>n-gram模型的作用就是，基于语料库计算出各种词串出现的概率，遇到一个句子的时候，可以直接使用上面所计算的概率，把所有的概率连乘，就得到了整个句子的概率。</p>
<h3 id="4-机器学习的思想"><a href="#4-机器学习的思想" class="headerlink" title="4. 机器学习的思想"></a>4. 机器学习的思想</h3><p>机器学习的套路是，对所研究的问题建模，构造一个目标函数，然后优化参数，最后用这个目标函数进行预测。</p>
<p>对于统计语言模型，常使用最大对数似然作为目标函数，即</p>
<script type="math/tex; mode=display">
L = \sum_{w\in C}logP(w\vert context(w))</script><p>,</p>
<p>在n-gram模型中，$context(w_i) = (w_{i-n+1},w_{i-n+2},\cdots,w_{i-1})$,</p>
<p>由此可见，概率$P(w_i\vert context(w_i))$是关于$w$和$context(w)$的函数，即</p>
<script type="math/tex; mode=display">
P(w\vert context(w)) = F(w,context(w),\theta)</script><p>,</p>
<p>一旦$F$确定下来了，任何概率都可以使用这个函数进行计算了。</p>
<p><strong>似乎到这里，我们仍然不知道词向量是什么，因为n-gram模型中根本没有用到词向量。那么，接下来将要介绍的神经网络语言模型则是实实在在用到了词向量。之所以提到统计语言模型，是因为它是其他语言模型的基础，我们得知道语言模型是干嘛的，然后再对语言模型进行展开。</strong></p>
<hr>
<h2 id="神经网络语言模型"><a href="#神经网络语言模型" class="headerlink" title="神经网络语言模型"></a>神经网络语言模型</h2><p>上面介绍的n-gram模型相信我们已经十分清楚了，但是n-gram模型的一个突出的确定就是，n的设置不宜过大，n从2到3提升效果显著，但是从3-4提升的效果就没那么好了。而且随着n的增大，参数的数量是以几何形势增长的。</p>
<p>因此，n-gram模型只能提取某个词前面两到三个词的信息，而不能提取更多的信息了。然而很明显的是，整文本序列中，包含更前面的词能够提供比仅仅2到3个词更多的信息，这也是神经网络语言模型着重要解决的问题之一。</p>
<p>神经网络模型主要在以下两点上寻求更大的进步：</p>
<ol>
<li><p>n-gram模型没有考虑上下文中更多的词提供的信息</p>
</li>
<li><p>n-gram模型没有考虑词与此之间的相似性。</p>
</li>
</ol>
<p><strong>举个栗子：</strong></p>
<p>如果在一个语料库中，”the cat is walking in the bedroom”出现了5000次，而”a dog is running in the room”只出现了5次，n-gram模型得出的结果是前面一个句子的可能性会比后面一个句子大得多。但是实际上，这两个句子是相似的，他们在真实的情况下出现的概率也应该是相仿的。</p>
<p>神经网络语言模型可以概括为以下三点：</p>
<ol>
<li><p>将词汇表中的每个词表示成一个在m维空间里的实数形式的分布式特征向量</p>
</li>
<li><p>使用序列中词语的分布式特征向量来表示连接概率函数</p>
</li>
<li><p>同时学习特征向量和概率函数的参数</p>
</li>
</ol>
<p>特征向量表示词的不同特征：每一个词都是向量空间内的一个点。特征的个数通常都比较小，比如30，60或者100，远远小于词汇表的长度。概率函数是在给定一个词前面的若干词的情况下，该词出现的条件概率。调整概率函数的参数，使得训练集的对数似然达到最大。每个词的特征向量是通过训练得到的，也可以用先验知识进行初始化。</p>
<ul>
<li><p>训练集是词序列$W_1,W_2,…,W_T,W_T\in V$,$V$是词汇表，是一个很大但是有限的集合。</p>
</li>
<li><p>目标是找到一个好的模型，使得$f(W_t,…,W_{t-n+1})=\hat{P}(W_t|W_1^{n-1})$</p>
</li>
<li><p>唯一的约束条件是$\sum _{i=1}^{|V|}f(i,W_{t-1},…,W_t-n+1)=1,f&gt;0$</p>
</li>
</ul>
<p><img src="/picture/nnlm.png" alt="photo"> </p>
<p>我们将函数$f(W_t,…,W_{t-n+1})$分解为以下两个部分：</p>
<ol>
<li><p>映射$C$，将$V$中的所有元素映射为真实的向量$C(i)\in R^m$，$C(i)$代表词汇表中的每个词的分布式特征向量，实际上，$C$是一个由自由参数构成的$|V|\times m$矩阵。其中$|V|$代表词汇表的大小，也就是词汇表中的词数量。</p>
</li>
<li><p>每个词的概率函数是由$C$来表示的：函数$g$将输入的词特征向量$(C(W_{t-n+1}),…,C(W_{t-1}))$映射为词$W_t$前面$n-1$个词的条件概率分布。</p>
</li>
</ol>
<script type="math/tex; mode=display">
f(i,W_{t-1},...,W_{t-n+1})=g(i,C(W_{t-1}),...,C(W_{t-n+1}))</script><p>函数$f$是由两个映射组成的($C\&amp;g$),$C$是所有词共享的。每一个部分都与一些参数有关。</p>
<p>映射$C$的参数实际上就是特征向量本身，表示为一个$|V|\times m$矩阵，矩阵的每一行代表词$i$的特征向量$C(i)$.</p>
<p>函数$g$的参数是$\omega$，所有的参数就是$\theta = (C,\omega)$.</p>
<p>当寻找到使得带惩罚项的训练语料库的对数似然率最大的$\theta$，那么训练完成。</p>
<script type="math/tex; mode=display">
L = \frac{1}{T}\sum _t log f(W_t,W_{t-1},...,W_t-n+1)+R(\theta)</script><p>$R(\theta)$是惩罚项，只作用于神经网络的权重和矩阵$C$。自由参数的规模是$V$的线性函数，也是$n$的线性函数。</p>
<p>在下面的大多数试验中，神经网络只有一个隐藏层，外加一个映射层。还有一个可选的直连层。所以说实际上有两个隐藏层，但是由于影射层只是做了一个线性变换，并没有添加新的信息，因此不能视为真正的隐藏层。所以真正的隐藏层就只有一个。</p>
<p>从图中可以看出，最底层实际上就是一些单一的词，表示成one-hot形式，即长度为词汇表的长度。然后，每个one-hot向量分别与投影矩阵C相乘，则原来长度为$|V|$的one-hot向量，经过线性变换以后，缩短为一个长度为$m$的向量，其中m就是我们设置的特征的个数，一般在2个数量级。投影完成以后，将所有的特征向量按照顺序首尾相连，形成一个长度为$m(n-1)$的向量，以词向量作为隐藏层的输入，隐藏层的激活函数为双曲正切函数$tanh$。输出层接受隐藏层的输出作为输入，经过一个softmax函数进行转换，得到最终的输出P.</p>
<p>即</p>
<script type="math/tex; mode=display">
\hat{P}(w_t\vert w_{t-1},...,w_{t-n+1})=\frac{e^{y_{w_t}}}{\sum_i e^{y_i}}</script><p>,</p>
<p>其中</p>
<script type="math/tex; mode=display">
y = b+Wx + Utanh(d+Hx)</script><p>双曲正切函数逐个应用于隐藏层的各个单元。当没有直连的时候，$W=0$，$x$是首尾相连的特征向量：</p>
<script type="math/tex; mode=display">
x = (C(w_{t-1}),C(w_{t-2}),...,C(w_{t-n+1}))</script><p>令$h$是隐藏层的单元数，$m$是特征向量的长度，当没有直连的时候，$W=0$。那么，所有的自由参数就是：</p>
<ul>
<li><p>输出层的偏置$b$，长度为|V|</p>
</li>
<li><p>隐藏层的偏置$d$，长度为$h$</p>
</li>
<li><p>隐藏层到输出层的权重矩阵$U$,是一个$|V|\times h$矩阵</p>
</li>
<li><p>词向量到输出层的权重矩阵$W$，是一个$|V|\times (n-1)m$矩阵</p>
</li>
<li><p>隐藏层权重$H$，是一个$h\times (n-1)m$矩阵</p>
</li>
<li><p>特征矩阵$C$，是一个$|V|\times m$矩阵</p>
</li>
</ul>
<p><strong>此时的输出$y$实际上是一个长度为$|V|$的向量，那么分量$y_{wt}$不能表示给出前(n-1)个词的情况下$w_t$的概率，因此需要进行一次归一化。</strong></p>
<p>那么，我们所有的参数如下：</p>
<script type="math/tex; mode=display">
\theta = (b,d,W,U,H,C)</script><p>主要的计算量都集中在隐藏层到输出层的以及输出层的归一化计算。</p>
<p>使用随机梯度下降进行参数求解：</p>
<script type="math/tex; mode=display">
\theta \leftarrow \theta + \epsilon\frac{\partial log \hat{P}(w_t\vert w_{t-1},w_{t-2},w_{t-n+1})}{\partial \theta}</script><p>其中，$\epsilon$是学习率。</p>
<p>当训练结束以后，矩阵$C$就是我们需要的词向量，每一行代表该位置的词的向量。得到了词向量，就可以进行许多有趣的分析。</p>
<p>比如：</p>
<ul>
<li><p>文本聚类</p>
</li>
<li><p>计算文本相似度</p>
</li>
<li><p>其他应用</p>
</li>
</ul>
<hr>
<h2 id="Skip-Gram-模型"><a href="#Skip-Gram-模型" class="headerlink" title="Skip-Gram 模型"></a>Skip-Gram 模型</h2><p>基本版的skip-gram模型是十分简单的。我们将会训练一个只有一个隐藏层的简单的神经网络来完成我们的任务，但是当神经网络训练完成以后，我们实际上并不使用这个网络做什么，而是获得隐藏层的权重矩阵，这个矩阵实际上就是我们需要的词向量(word vectors)</p>
<p>skip-gram模型需要完成这样的工作：给定一个词，预测其周围的词，或者说在其附近的词。这个神经网络将会计算出我们从词汇表中选出的每个“候选”邻居词的概率。</p>
<p>这里的附近需要说明一下，实际上在算法里有一个”window size”参数，用来控制窗口大小，如果选择参数的值为5，则会预测该词前后各5个词的概率。</p>
<p>skip-gram模型的输入需要经过特殊的调整，不同于上述神经网络语言模型，应该首先将这里的语料整理成词对(word-pair)。</p>
<p>比如对于语句”The quick brown fox jumps over the lazy dog.”此处我们选择window size = 2.</p>
<p><img src="/picture/3.png" alt="input of skip gram"></p>
<p>具体操作如图所示：</p>
<ul>
<li><p>对于单词”The”，取其前后两个词与其凑成词对，这里”The”前面没有单词，因此取后面两个，凑成两个词对，分别是(the,quick),(the,brown)。</p>
</li>
<li><p>对于单词quick，其前面有1个单词，后面有2个单词，可以凑成3对，分别为：(quick,the),(quick,brown),(quick,fox)。</p>
</li>
<li><p>对于单词brown，其前面有两个单词，后面有两个单词，可以凑成4对，分别是：(brown,the),(brown,quick),(browm,fox),(brown,fox)。</p>
</li>
</ul>
<p>以此类推，可以把语料库中的所有文本调整成上述词对。</p>
<p>所有的词对都应该是(input,output)形式。</p>
<p>有了词对，接下来看一下skip-gram的最简单的模型长什么样子。</p>
<p><img src="/picture/4.png" alt="skip-gram  diagram"></p>
<p>在上图中，可以清晰地看出，skip-gram模型是一个简单的神经网络，有一个隐藏层（实际上在作者的论文中是以投影层的形式表述的），该隐藏层并没有对应的激活函数。</p>
<p>输入数据仍然是one-hot向量，向量只有一个分量是1，其他全为0.向量的长度为词汇表的长度。</p>
<p>对下面所要用的符号进行说明：</p>
<ul>
<li><p>$i$：输入的one-hot向量，长度为|V|</p>
</li>
<li><p>$|V|$：词汇表的长度</p>
</li>
<li><p>$P$：输入层到投影层的$|V|\times m$权重矩阵</p>
</li>
<li><p>$W$：投影层到输出层的$m\times |V|$权重矩阵</p>
</li>
<li><p>$y$：输出层输出结果</p>
</li>
</ul>
<p>由于这个神经网络没有激活函数，因此看起来比较简单。</p>
<p>神经网络的计算过程如下：</p>
<ul>
<li><p>首先，将输入词向量(one-hot)投影到隐藏层(投影层)，即<script type="math/tex">i^T\times P=1\times |V|\times |V| \times m=1\times m</script></p>
</li>
<li><p>将隐藏层的结果乘以隐藏层到输出层的权重矩阵$W$，即<script type="math/tex">1\times m \times m\times |V|=1\times |V|</script></p>
</li>
<li><p>将输出层的输出结果进行softmax归一化，即</p>
</li>
</ul>
<script type="math/tex; mode=display">y=\frac{e^{y}}{\sum_{i\in y}e^i }</script><p>此时$y$是一个$1\times |V|$向量，向量的每个分量代表给定词$w_i$的情况下，其相邻词是词汇表中对应词的概率。将$y$与output的one-hot向量相乘，就可以得到给定$w_i$的情况下，其相邻词是output的概率，即</p>
<script type="math/tex; mode=display">
P(w_o\vert w_i)=y\times w_o</script><p>,</p>
<p>其中，$w_o$是词output的向量形式。</p>
<p><strong>以上矩阵相乘只是为了说明维度变化，并不是实际上的矩阵乘法。</strong></p>
<p>用矩阵说明如下：</p>
<p>假定我们的词库大小为10，输出层到投影层的权重矩阵为$10\times 4$矩阵。</p>
<p>我们的输入样本是词对(brown,quick).其中，brown的one-hot表示形式如图中的蓝色向量所示，quick的one-hot表示形式如图中的浅绿色向量所示。</p>
<ul>
<li><p>蓝色向量是我们的输入向量，即one-hot向量</p>
</li>
<li><p>黄色矩阵是输入层到投影层的权重矩阵</p>
</li>
<li><p>绿色向量是输入向量与第一个权重矩阵的向量乘积</p>
</li>
<li><p>棕色矩阵是投影层到输出层的权重矩阵</p>
</li>
<li><p>灰色向量是绿色向量与棕色矩阵的矩阵乘积</p>
</li>
<li><p>红色向量是对灰色向量进行了一次$softmax$归一化计算</p>
</li>
<li><p>浅绿色矩阵是词对中的输出词对应的one-hot向量</p>
</li>
<li><p>深红色数值是我们计算出的输出词对应的概率</p>
</li>
</ul>
<p><strong>skip-gram的目标是对于训练样本$w_1,w_2,\cdots,w_T$,最大化如下平均对数似然概率：</strong></p>
<p><img src="/picture/5.jpg" alt="matrix2"></p>
<script type="math/tex; mode=display">
\frac{1}{T}\sum _{t=1}^T\sum_{-c\le i\le c,j\ne 0}log p(w_{t+j}\vert w_t)</script><p>实际上，以上模型是难以实现的，因为计算 $\nabla logp(w_O\vert w_I)$的代价随着$W$的增大而增大(W表示词汇表的长度),经常达到$10^5-10^7$数量级。</p>
<h2 id="Hierarchical-Softmax"><a href="#Hierarchical-Softmax" class="headerlink" title="Hierarchical Softmax"></a>Hierarchical Softmax</h2><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a><strong>哈夫曼树</strong></h3><p>哈夫曼树是一种最优二叉树，它是这样定义的：</p>
<pre><code>给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树。
</code></pre><p>哈夫曼树的构造方法如下：</p>
<p>(1) 将$w_1,w_2,\cdots,w_n$看成是有n 棵树的森林(每棵树仅有一个结点)；</p>
<p>(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</p>
<p>(3)从森林中删除选取的两棵树，并将新树加入森林；</p>
<p>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树</p>
<p>假设我们的权值为：26    24    15    10    17    18    10    27</p>
<p>首先对上面的权值按照从小到大排序：</p>
<pre><code>排序后的权值为：10 10 15 17 18 24 26 27
</code></pre><p>然后。我们按照上述步骤构建哈夫曼树。</p>
<p><strong>此处我们约定将大的权值放在左子树。</strong></p>
<p>—-Begin</p>
<ul>
<li><p>选择最小的两个权值10，10，合并成一个新树的左右子树。新树的权值为20，删除合并的两个权值，将20加入到森林，此时的权值为（仍然进行排序）：15 17 18 <strong>20</strong> 24 26 27</p>
</li>
<li><p>选择最小的15和17合并，删除15和17，将32加入到森林，此时的权值为：18 20 24 26 27 <strong>32</strong></p>
</li>
<li><p>选择最小的18和20合并，删除18和20，将38加入到森林，此时的权值为：24 26 27 32 <strong>38</strong></p>
</li>
<li><p>选择最小的24和26合并，删除24和26，将20加入到森林，此时的权值为：27 32 38 <strong>50</strong></p>
</li>
<li><p>选择最小的27和32合并，删除27和32，将59加入到森林，此时的权值为：38 50 <strong>59</strong></p>
</li>
<li><p>选择最小的38和50合并，删除38和50，将88加入到森林，此时的权值为：59 <strong>88</strong></p>
</li>
<li><p>选择最小的59和88合并，删除59和88，将147加入到森林，此时的权值为：<strong>147</strong></p>
</li>
</ul>
<p>—-End</p>
<p>根据上述权值构造的哈夫曼树如下：</p>
<p><img src="/picture/6.png" alt="Huffman Tree"></p>
<p><strong>背景为黄色的是新生成的树</strong></p>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a><strong>逻辑回归</strong></h3><p>逻辑回归通常用来处理二分类问题，因变量通常只有两个可能的取值，自变量既可以是连续型变量，也可以是分类变量。</p>
<p>利用sigmoid函数，对于任意的样本$x=(x_1,x_2,\cdots,x_n)^T$，可将二分类问题的h函数(hypothesis)写成如下形式：</p>
<script type="math/tex; mode=display">
h_\theta(x)=\sigma(\theta_0+\theta_1x_1+\cdots+\theta_nx_n)</script><p>,</p>
<p>其中$\theta =(\theta_0,\theta_1,\cdots,\theta_n)$为待定参数，为了简化起见，可以引入$x_0=1$将$x$扩展为$(x_0,x_1,\cdots,x_n)$,于是，$h_\theta$可简写为</p>
<script type="math/tex; mode=display">
h_\theta(x)=\sigma(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}</script><p>sigmoid函数图像如下：</p>
<p><img src="/picture/7.png" alt="sigmoid"></p>
<p><strong>函数$h_\theta(x)$的值有特殊的含义，它表示结果取1的概率，因此对于输入$x$,分类结果为类别1和类别0的概率分别为：</strong></p>
<script type="math/tex; mode=display">
P(y=1\vert x;\theta)=h_\theta(x)</script><script type="math/tex; mode=display">
P(y=0\vert x;\theta)=1-h_\theta(x)</script><p>上式也可以写成如下综合形式：</p>
<script type="math/tex; mode=display">
P(y\vert x;\theta)=(h_\theta(x))^y(1-h_\theta(x))^{1-y}</script><p><strong>sigmoid函数具有很好的导数特征</strong></p>
<p>已知</p>
<script type="math/tex; mode=display">
\sigma(x) = \frac{1}{1+e^{-x}}</script><p>则</p>
<script type="math/tex; mode=display">
\sigma(x)^{'}=\frac{e^{-x}}{(1+e^{-x})^2}=\sigma(x)(1-\sigma(x))</script><p>另外</p>
<script type="math/tex; mode=display">
[log\sigma(x)]^{'}=1-\sigma(x),[log(1-\sigma(x))^{'}=- \sigma(x)</script><h3 id="Hierarchical-Softmax-1"><a href="#Hierarchical-Softmax-1" class="headerlink" title="Hierarchical Softmax"></a><strong>Hierarchical Softmax</strong></h3><p>hierarchical softmax使用一颗二叉树的叶子结点来代表输出层对应词汇表中每个词的输出结果。每个结点都代表了它的孩子结点的相关概率。这种方式定义了一种给词分配概率的随机游走解决方案。</p>
<p>准确地说，从根结点出发，每一个词都能以一条确定的路径抵达。对所使用的符号作如下阐述：</p>
<ul>
<li><p>$w$：代表词汇表中的词，用叶子结点表示</p>
</li>
<li><p>$n(w,j)$：从根结点到达某个叶子结点的路径上的第$j$个结点，根结点为第一个结点</p>
</li>
<li><p>$L(w)$：路径的长度，也就是结点的个数</p>
</li>
</ul>
<p>因此，$n(w,1)=root,n(w,L(w))=w$</p>
<ul>
<li><p>$n$：非叶子结点</p>
</li>
<li><p>$ch(n)$：非叶子结点的孩子结点</p>
</li>
<li><p>$[[x]]$：if x is true,than 1,else than -1</p>
</li>
</ul>
<p>hierarchical softmax定义$P(w_o\vert w_i)$如下：</p>
<script type="math/tex; mode=display">
P(w\vert w_i)=\prod_{j=1}^{L(w)-1}\sigma([[n(w,j+1)=ch(n(w,j))]]\cdot (v^{'}_{n(w,j)})^T v_{w_i})</script><p>其中</p>
<script type="math/tex; mode=display">
\sigma(x)=1/(1+e^{-x})</script><p>可以证明：</p>
<script type="math/tex; mode=display">
\sum _{i=1}^Wp(w\vert w_i)=1</script><p>那么，hierarchical softmax框架下的skip-gram结构是什么样的呢?</p>
<p><img src="/picture/8.png" alt="hierarchical softmax skip-gram"></p>
<p>如上图所示，与basic版本的skip-gram模型相比，hierarchical softmax版本的模型输出层不再是线性结构，而是树形结构。</p>
<p>上面已经说过，线性结构的skip-gram模型的参数规模十分庞大，最大能够达到$10^7$数量级，再加上动辄10亿级别的语料库，训练代价很高，效率就特别低了。</p>
<p>引入了hierarchical softmax以后，输出层的维度得到了大幅降低。正如作者所说，计算$logp(w_o\vert w_i)$和$\nabla logp(w_o\vert w_i)$的代价是与$L(w_o)$也就是哈夫曼树的深度成正比的。</p>
<p><strong>下面假装正经地推导参数的更新过程：</strong></p>
<p>假设我们的训练样本是【今天我上课迟到了，然后被老师批评了】，对应词汇表中的词汇为【今天 我 上课 迟到 了 然后 被 老师 批评】</p>
<p>假设在语料库中，上述词汇对应的频数如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">词汇</th>
<th style="text-align:center">频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">今天</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">我</td>
<td style="text-align:center">15</td>
</tr>
<tr>
<td style="text-align:center">上课</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">迟到</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">了</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">然后</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">被</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">老师</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">批评</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>将频率看做是哈夫曼树的权值，将大的权值放在左子树，小的权值放在右子树。</p>
<p>绘制出的带权值的哈夫曼树如下：</p>
<p><img src="\picture\9.png" alt="output"></p>
<p>说明如下：</p>
<ul>
<li><p>黄色的结点表示新生成的树</p>
</li>
<li><p>$\theta_i^w \in R^m$，非叶子结点对应的向量</p>
</li>
<li><p>$d_1^w,d_2^w,\cdots,d_{l(w)-1}^w \in \{0,1\}$：词$w$的哈夫曼编码，由$l(w)-1$位编码构成，$d_j^w$对应对应路径中第$j$个非叶子结点的编码(0 or 1).</p>
</li>
</ul>
<p>根据基于hierarchical softmax的skip-gram模型，投影层将输入的one-hot向量投影成$R^m$空间中的向量，即输出层接受的输入为投影层的输出，即$v_m$。</p>
<p>目标函数仍然是最大化对数似然概率，那么，当前的重点是条件概率函数的构造。</p>
<p>skip-gram模型将其定义为</p>
<script type="math/tex; mode=display">P(context(w_i)\vert w_i)=\prod _{u\in context(w_i)}p(u\vert w_i)</script><p>而根据hierarchical softmax的思想，$p(u\vert w_i)$可以写出如下形式：</p>
<script type="math/tex; mode=display">p(u\vert w_i)=\prod _{j=2}^{l(w)}p(d_j^u\vert v_m;\theta_{j-1}^u)</script><p>其中</p>
<script type="math/tex; mode=display">p(d_j^u\vert v_m;\theta_{j-1}^u)=[\sigma(v_m^T\theta^u_{j-1})]^{1-d_j^u}\cdot[1-\sigma(v_m^T\theta^u_{j-1})]^{d_j^u}</script><p>那么，我们的目标函数可以写成如下形式：</p>
<script type="math/tex; mode=display">L=\sum _{w\in C} log \prod _{u\in context(w)}\prod _{j=2}^{l(w)}[\sigma(v_m^T\theta^u_{j-1})]^{1-d_j^u}\cdot[1-\sigma(v_m^T\theta^u_{j-1})]^{d_j^u}</script><script type="math/tex; mode=display">=\sum _{w\in C}\sum _{u \in context(w)}\sum _{j=2}^{l(w)}\{(1-d_j^u)\cdot log[\sigma(v_m^T\theta^u_{j-1})]+d_j^u\cdot log[1-\sigma(v_m^T\theta^u_{j-1})]\}</script><p>上面的函数就是skip-gram的目标函数，为了方便推导梯度，将三重求和符号下花括号的内容简记为$L(w,u,j)$，即</p>
<script type="math/tex; mode=display">L(w,u,j)=(1-d_j^u)\cdot log[\sigma(v_m^T\theta^u_{j-1})]+d_j^u\cdot log[1-\sigma(v_m^T\theta^u_{j-1})]</script><p>首先考虑$L$关于$\theta_{j-1}^u$的梯度计算：</p>
<script type="math/tex; mode=display">\frac{\partial L}{\partial \theta_{j-1}^u}=\frac{\partial L(w,u,j)}{\partial \theta_{j-1}^u}=\frac{\partial \{(1-d_j^u)\cdot log[\sigma(v_m^T\theta^u_{j-1})]+d_j^u\cdot log[1-\sigma(v_m^T\theta^u_{j-1})]\}}
{\partial \theta_{j-1}^u}=[1-d_j^u-\sigma(v_m^T\theta_{j-1}^u)]\cdot v_m</script><p>于是，$\theta_{j-1}^u$的更新公式可写为：</p>
<script type="math/tex; mode=display">\theta_{j-1}^u\leftarrow \theta_{j-1}^u+\epsilon [1-d_j^u-\sigma(v_m^T\theta_{j-1}^u)]\cdot v_m</script><p>接下来考虑$L$对$v_m$的梯度。由于在$L$中，$v_m$与$\theta_{j-1}^u$具有对称性，因此可以根据上述所求，直接写出$v_m$的更新公式：</p>
<script type="math/tex; mode=display">v_m\leftarrow v_m+\epsilon \sum _{u\in C}\sum _{j=2}^{l(w)}\frac{\partial L(w,u,j)}{\partial v_m}</script><p>其中，$\epsilon$是学习率。</p>
<h2 id="Negative-Sampling-and-Subsampling-of-Frequent-Words"><a href="#Negative-Sampling-and-Subsampling-of-Frequent-Words" class="headerlink" title="Negative Sampling and Subsampling of Frequent Words"></a>Negative Sampling and Subsampling of Frequent Words</h2><p>考虑到basic版本的skip-gram模型拥有两个异常巨大的权重矩阵，再加上一个10亿数量级的语料库，神经网络跑起来会非常吃力。</p>
<p>word2vec的作者是这样处理这个问题的，主要有以下三个创新点：</p>
<ol>
<li><p>将常用词对或者词组看成一个单独的词</p>
</li>
<li><p>subsampling(降采样)出现频率很高的词以减小训练样本的大小</p>
</li>
<li><p>使用一种被称为”Negative Sampling”的方法来改变优化目标，这种方法在训练时只优化与训练样本有关的很小一丢丢权重。</p>
</li>
</ol>
<p><strong>值的一提的是，应用Subsampling和NEG方法不仅可以减小计算压力，还能提高最终产生的词向量的质量。</strong></p>
<h3 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h3><p>回想一下那个basic版本的skip-gram，神经网络的真实值或者说标签是一个one-hot矩阵，也就是说，只有一个分量是1，而其他分量都是0(成千上万个0)。但是我们在更新神经网络权重的时候，对于所有的输出为0的权重都进行了更新，这样效率是比较差的。</p>
<p>negative sampling的思想就是，当我们在训练一个特定样本的时候，能不能只更新几个输出为0的权重，这样计算起来就比较轻松了。</p>
<p>我们把one-hot向量分量为负的位置所对应的词称为negative words，在训练一次样本时，我们只更新几个(假如说5个吧)negative words，同时也更新我们的pisitive words(即分量为1所对应的位置在词汇表中对应的词)。</p>
<p>作者在论文中说到，当样本量比较小的时候，选择5-20个negative words效果会比较好，当样本量比较大的时候，2-5个negative words就能得到很好的效果。</p>
<p>现在假设我们在basic model中需要更新的权重矩阵为$300\times 10000$矩阵，那么basic model每次迭代需要更新$3\times 10^6$个参数，而采用了negative sampling 方法以后，我们只需要更新5个negative words和1个positive words对应的权重，也就是$300\times (5+1)=1800$个权重，是原来的$1800/3\times 10^6=0.06\%$.</p>
<p>想法是好的，我们要怎么选择这5个negative words呢？</p>
<p>我们知道，语料库中的每个词都有一定的频率，那么我们就利用频率这个信息，对negative words进行采样。</p>
<p>由此可见，高频词被选为negative words的概率就比较大，同理，低频词被选为negative words的概率就比较小。</p>
<p>作者的处理方法是，赋予每一个词被选为negative words的概率，具体计算公式如下：</p>
<script type="math/tex; mode=display">
P(w_i)=\frac{f(w_i)^{0.75}}{\sum _{j=0}^nf(w_i)^{0.75}}</script><p>,</p>
<p>至于为什么是0.75，这是作者及其团队经过不断试验得出的效果比较好的，没有特别的原因。</p>
<p>计算出了概率，我们又怎么选择相应的negative words呢？</p>
<p>作者在其代码中给出了答案。</p>
<p><strong>下面给出了具体的方法：</strong></p>
<ol>
<li><p>构造一个很长的数组,作者的数组长度达到了1000000</p>
</li>
<li><p>将词汇表中的每个词对应的index(索引)向数组中填充多次，填充的次数是这样计算的：</p>
</li>
</ol>
<p>根据一元模型可以从语料库生成样本（也就是把语料库中的文本以词的形式展示）</p>
<p>填充次数times的计算公式为：</p>
<script type="math/tex; mode=display">
times = P(w_i)\times 100000</script><ol>
<li>欲选出你的negative words，只需要在0-100M之间随机生成一个整数，以这个整数为索引，在数组中查找元素，该元素也是一个索引，根据这个元素从词汇表中查找negative words。</li>
</ol>
<p><strong>不难理解，$P(w_i)$大的被选中的概率就大。</strong></p>
<h3 id="Subsampling-of-Frequent-Words"><a href="#Subsampling-of-Frequent-Words" class="headerlink" title="Subsampling of Frequent Words"></a>Subsampling of Frequent Words</h3><p>让我们再看一遍词对的生成过程。</p>
<p><img src="/picture/3.png" alt="word-pairs"></p>
<p>如上图所示，我们设定window size = 2 来生成样本。对于包含”the”的词对来说，有以下两个问题：</p>
<ol>
<li><p>当我们在寻找词对的时候，(“fox”,”the”)所能提供的信息并不比”fox”多。然而，”the”几乎在上面的所有词对中都有出现。</p>
</li>
<li><p>形如(“the”,…)这样的词对已经远远超过了我们的需求。</p>
</li>
</ol>
<p>word2vec 应用了一种称之为subsampling的方法来解决这个问题。</p>
<p>对于我们遇到每一个语料库中的词，都有一定的概率将它从语料库中删除，删除的概率与该词出现的频率有关。</p>
<p>如果我们将window size 设置为10，我们是这样删除”the”相关样本的：</p>
<ol>
<li><p>我们在训练其他词的时候，”the”不会出现在他们的窗口</p>
</li>
<li><p>当输入词是”the”的时候，将样本数减少10个(不减少的情况下是20)</p>
</li>
</ol>
<p>那么，我们怎么决定是否删除一个词呢？</p>
<p>假设$w_i$是待定删除的词，$z(w_i)$是$w_i$在语料库中出现的频率,$P(w_i)$是保留该词的概率:</p>
<script type="math/tex; mode=display">
P(w_i)=(\sqrt{\frac{z(w_i)}{0.001}}+1)\cdot \frac{0.001}{z(w_i)}</script><p><strong>0.001也是一个经验参数，如果比0.001还要小，那么保留词的概率就会更小。</strong></p>
<p>下面是$P(w_i)$函数的图像：</p>
<p><img src="/picture/10.png" alt="p(wi)"></p>
<p>从图像可以看出：</p>
<ul>
<li><p>当频率等于0.0026的时候，被保留的概率为1，也就是说，当频率大于0.0026的时候，就有可能被删除。</p>
</li>
<li><p>当频率为0.0074的时候，有一半的概率会被保留</p>
</li>
<li><p>当频率为0.1的时候，被保留的概率就骤减到0.1</p>
</li>
</ul>
<h3 id="Learning-Phrase"><a href="#Learning-Phrase" class="headerlink" title="Learning Phrase"></a>Learning Phrase</h3><p>learning phrase 方法使得样本更加接近真实世界。考虑以下句子：</p>
<pre><code>New York is a beautiful and modern city where I want to have a travel.
</code></pre><p>我们设置窗口大小为4，对beautiful进行采样，获得如下样本：</p>
<pre><code>(beautiful,New) (beautiful,York) (beautiful,is) (beautiful,a) (beautiful,New) (beautiful,and) (beautiful,modern) (beautiful,city) 
</code></pre><p>采用一元的方法，会将常用的词组分开，从而降低词向量的质量。</p>
<p>我们可以采取一个简单的数据驱动的方法，来对两个词是否能组成词组进行打分：</p>
<script type="math/tex; mode=display">
score(w_i,w_j) = \frac{count(w_iw_j)-\delta}{count(w_i)\times count(w_j)}</script><p>$\delta$作为一个折扣系数的作用，用来防止那些不怎么经常一起出现的词语形成词组。当score超过了我们设置的阈值时，将两个词视为词组。</p>
<p>上述打分程序可以多进行几次，以获得三元组或者更多词的词组。</p>
<hr>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]McCormick, C. (2016, April 19). Word2Vec Tutorial - The Skip-Gram Model. Retrieved from <a href="http://www.mccormickml.com" target="_blank" rel="noopener">http://www.mccormickml.com</a></p>
<p>[2]Pennington J, Socher R, Manning C. Glove: Global Vectors for Word Representation[C]// Conference on Empirical Methods in Natural Language Processing. 2014:1532-1543.</p>
<p>[3]Mikolov T, Le Q V, Sutskever I. Exploiting Similarities among Languages for Machine Translation[J]. Computer Science, 2013.</p>
<p>[4]Mikolov T, Chen K, Corrado G, et al. Efficient Estimation of Word Representations in Vector Space[J]. Computer Science, 2013.</p>
<p>[5]Bengio, Y &amp; Ducharme, Réjean &amp; Vincent, Pascal. (2000). A Neural Probabilistic Language Model. Journal of Machine Learning Research. 3. 932-938. 10.1162/153244303322533223. </p>
<p>[6]NSS,(JUNE 4, 2017).An Intuitive Understanding of Word Embeddings: From Count Vectors to Word2Vec.Retrieved from <a href="https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2017/06/word-embeddings-count-word2veec/</a></p>
<p>[7]peghoty,2014年07月.word2vec 中的数学原理详解.<a href="http://blog.csdn.net/itplus/article/details/37969519" target="_blank" rel="noopener">http://blog.csdn.net/itplus/article/details/37969519</a></p>
<p>[8]吴军．数学之美[M]．北京：人民邮电出版社，2014.</p>
<p>==========================The End=============================</p>

            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《Word2Vec-语言模型的前世今生》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2018/03/27/词向量/" property="cc:attributionName"
               rel="cc:attributionURL">
                冯洋洋
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2018/03/30/Introduction-to-ETL/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="Introduction to ETL">
                        
                        <span class="card-title">Introduction to ETL</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-03-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/大数据/" class="post-category" target="_blank">
                                    大数据
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/ETL/" target="_blank">
                        <span class="chip bg-color">ETL</span>
                    </a>
                    
                    <a href="/tags/数据仓库/" target="_blank">
                        <span class="chip bg-color">数据仓库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6 overflow-policy" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="fa fa-dot-circle-o"></i>
            </div>
            <div class="card">
                <a href="/2018/03/27/词向量/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Word2Vec-语言模型的前世今生">
                        
                        <span class="card-title">Word2Vec-语言模型的前世今生</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            引言
在机器学习领域，语言识别和图像识别都比较容易做到。语音识别的输入数据可以是音频频谱序列向量所构成的matrix，图像识别的输入数据是像素点向量构成的矩阵。但是文本是一种抽象的东西，显然不能直接把文本数据喂给机器当做输入，因此这里就需要
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-03-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/NLP/" class="post-category" target="_blank">
                                    NLP
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/自然语言处理/" target="_blank">
                        <span class="chip bg-color">自然语言处理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:xxx@xx.xx" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=123123123" class="tooltipped" data-tooltip="QQ联系我: 123123123" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>